import {
  require_react_dom
} from "./chunk-JZ3YVIXN.js";
import {
  require_react
} from "./chunk-6CE3F7YD.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/yet-another-react-lightbox/dist/core/consts.js
var MODULE_CAROUSEL = "carousel";
var MODULE_CONTROLLER = "controller";
var MODULE_CORE = "core";
var MODULE_NAVIGATION = "navigation";
var MODULE_NO_SCROLL = "no-scroll";
var MODULE_PORTAL = "portal";
var MODULE_TOOLBAR = "toolbar";
var PLUGIN_FULLSCREEN = "fullscreen";
var PLUGIN_SLIDESHOW = "slideshow";
var PLUGIN_THUMBNAILS = "thumbnails";
var PLUGIN_ZOOM = "zoom";
var SLIDE_STATUS_LOADING = "loading";
var SLIDE_STATUS_PLAYING = "playing";
var SLIDE_STATUS_ERROR = "error";
var SLIDE_STATUS_COMPLETE = "complete";
var SLIDE_STATUS_PLACEHOLDER = "placeholder";
var activeSlideStatus = (status) => `active-slide-${status}`;
var ACTIVE_SLIDE_LOADING = activeSlideStatus(SLIDE_STATUS_LOADING);
var ACTIVE_SLIDE_PLAYING = activeSlideStatus(SLIDE_STATUS_PLAYING);
var ACTIVE_SLIDE_ERROR = activeSlideStatus(SLIDE_STATUS_ERROR);
var ACTIVE_SLIDE_COMPLETE = activeSlideStatus(SLIDE_STATUS_COMPLETE);
var YARL_EVENT_BACKDROP_CLICK = "backdrop_click";
var YARL_EVENT_TOOLBAR_WIDTH = "toolbar-width";
var CLASS_FULLSIZE = "fullsize";
var CLASS_FLEX_CENTER = "flex_center";
var CLASS_NO_SCROLL = "no_scroll";
var CLASS_NO_SCROLL_PADDING = "no_scroll_padding";
var ACTION_PREV = "prev";
var ACTION_NEXT = "next";
var ACTION_SWIPE = "swipe";
var ACTION_CLOSE = "close";
var EVENT_ON_POINTER_DOWN = "onPointerDown";
var EVENT_ON_POINTER_MOVE = "onPointerMove";
var EVENT_ON_POINTER_UP = "onPointerUp";
var EVENT_ON_POINTER_LEAVE = "onPointerLeave";
var EVENT_ON_POINTER_CANCEL = "onPointerCancel";
var EVENT_ON_KEY_DOWN = "onKeyDown";
var EVENT_ON_KEY_UP = "onKeyUp";
var EVENT_ON_WHEEL = "onWheel";
var VK_ESCAPE = "Escape";
var VK_ARROW_LEFT = "ArrowLeft";
var VK_ARROW_RIGHT = "ArrowRight";
var ELEMENT_BUTTON = "button";
var ELEMENT_ICON = "icon";
var IMAGE_FIT_CONTAIN = "contain";
var IMAGE_FIT_COVER = "cover";

// node_modules/yet-another-react-lightbox/dist/props.js
var AnimationDefaultProps = {
  fade: 330,
  swipe: 500
};
var LightboxDefaultProps = {
  open: false,
  close: () => {
  },
  index: 0,
  slides: [],
  render: {},
  plugins: [],
  toolbar: { buttons: [ACTION_CLOSE] },
  labels: {},
  animation: AnimationDefaultProps,
  carousel: {
    finite: false,
    preload: 2,
    padding: "16px",
    spacing: "30%",
    imageFit: IMAGE_FIT_CONTAIN
  },
  controller: {
    focus: true,
    aria: false,
    touchAction: "none",
    closeOnBackdropClick: false
  },
  on: {},
  styles: {},
  className: ""
};

// node_modules/yet-another-react-lightbox/dist/core/utils.js
var React = __toESM(require_react(), 1);
var clsx = (...classes) => [...classes].filter((cls) => Boolean(cls)).join(" ");
var cssPrefix = "yarl__";
var cssClass = (name) => `${cssPrefix}${name}`;
var cssVar = (name) => `--${cssPrefix}${name}`;
var composePrefix = (base, prefix) => `${base}${prefix ? `_${prefix}` : ""}`;
var makeComposePrefix = (base) => (prefix) => composePrefix(base, prefix);
var label = (labels, lbl) => labels && labels[lbl] ? labels[lbl] : lbl;
var cleanup = (...cleaners) => () => {
  cleaners.forEach((cleaner) => {
    cleaner();
  });
};
var makeUseContext = (name, contextName, context) => () => {
  const ctx = React.useContext(context);
  if (!ctx) {
    throw new Error(`${name} must be used within a ${contextName}.Provider`);
  }
  return ctx;
};
var hasWindow = () => typeof window !== "undefined";
var isDefined = (x) => typeof x !== "undefined";
var isNumber = (value) => typeof value === "number";
var round = (value, decimals = 0) => {
  const factor = 10 ** decimals;
  return Math.round((value + Number.EPSILON) * factor) / factor;
};
var isImageSlide = (slide) => !isDefined(slide.type) || slide.type === "image";
var parseLengthPercentage = (input) => {
  if (typeof input === "number") {
    return { pixel: input };
  }
  if (typeof input === "string") {
    const value = parseInt(input, 10);
    return input.endsWith("%") ? { percent: value } : { pixel: value };
  }
  return { pixel: 0 };
};
var devicePixelRatio = () => (typeof window !== "undefined" ? window === null || window === void 0 ? void 0 : window.devicePixelRatio : void 0) || 1;
var getSlideIndex = (index, slidesCount) => (index % slidesCount + slidesCount) % slidesCount;
var getSlide = (slides, index) => slides[getSlideIndex(index, slides.length)];
var getAnimationEasing = (animationSpec) => typeof animationSpec === "object" ? animationSpec.easing : void 0;
var getAnimationDuration = (animationSpec, defaultDuration) => {
  var _a;
  return (_a = typeof animationSpec === "object" ? animationSpec.duration : animationSpec) !== null && _a !== void 0 ? _a : defaultDuration;
};
var getFadeAnimationDuration = (animation) => getAnimationDuration(animation.fade, AnimationDefaultProps.fade);
var getSwipeAnimationDuration = (animation) => getAnimationDuration(animation.swipe, AnimationDefaultProps.swipe);
var getNavigationAnimationDuration = (animation) => getAnimationDuration(animation.navigation, getSwipeAnimationDuration(animation));

// node_modules/yet-another-react-lightbox/dist/core/config.js
var createModule = (name, component) => ({
  name,
  component
});
var createNode = (module, children) => ({
  module,
  children
});
var traverseNode = (node, target, apply) => {
  if (node.module.name === target) {
    return apply(node);
  }
  if (node.children) {
    return [
      createNode(node.module, node.children.flatMap((n) => {
        var _a;
        return (_a = traverseNode(n, target, apply)) !== null && _a !== void 0 ? _a : [];
      }))
    ];
  }
  return [node];
};
var traverse = (nodes, target, apply) => nodes.flatMap((node) => {
  var _a;
  return (_a = traverseNode(node, target, apply)) !== null && _a !== void 0 ? _a : [];
});
var withPlugins = (root, plugins = [], augmentations = []) => {
  let config = root;
  const contains = (target) => {
    const nodes = [...config];
    while (nodes.length > 0) {
      const node = nodes.pop();
      if ((node === null || node === void 0 ? void 0 : node.module.name) === target)
        return true;
      if (node === null || node === void 0 ? void 0 : node.children)
        nodes.push(...node.children);
    }
    return false;
  };
  const addParent = (target, module) => {
    if (target === "") {
      config = [createNode(module, config)];
      return;
    }
    config = traverse(config, target, (node) => [createNode(module, [node])]);
  };
  const append = (target, module) => {
    config = traverse(config, target, (node) => [createNode(node.module, [createNode(module, node.children)])]);
  };
  const addChild = (target, module, precede) => {
    config = traverse(config, target, (node) => {
      var _a;
      return [
        createNode(node.module, [
          ...precede ? [createNode(module)] : [],
          ...(_a = node.children) !== null && _a !== void 0 ? _a : [],
          ...!precede ? [createNode(module)] : []
        ])
      ];
    });
  };
  const addSibling = (target, module, precede) => {
    config = traverse(config, target, (node) => [
      ...precede ? [createNode(module)] : [],
      node,
      ...!precede ? [createNode(module)] : []
    ]);
  };
  const replace = (target, module) => {
    config = traverse(config, target, (node) => [createNode(module, node.children)]);
  };
  const remove = (target) => {
    config = traverse(config, target, (node) => node.children);
  };
  const augment = (augmentation) => {
    augmentations.push(augmentation);
  };
  plugins.forEach((plugin) => {
    plugin({
      contains,
      addParent,
      append,
      addChild,
      addSibling,
      replace,
      remove,
      augment
    });
  });
  return {
    config,
    augmentation: (props) => augmentations.reduce((acc, augmentation) => augmentation(acc), props)
  };
};

// node_modules/yet-another-react-lightbox/dist/core/modules/Controller.js
var React19 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/core/hooks/useAnimation.js
var React4 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/core/hooks/useLayoutEffect.js
var React2 = __toESM(require_react(), 1);
var useLayoutEffect2 = hasWindow() ? React2.useLayoutEffect : React2.useEffect;

// node_modules/yet-another-react-lightbox/dist/core/hooks/useMotionPreference.js
var React3 = __toESM(require_react(), 1);
function useMotionPreference() {
  const [reduceMotion, setReduceMotion] = React3.useState(false);
  React3.useEffect(() => {
    var _a, _b;
    const mediaQuery = (_a = window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, "(prefers-reduced-motion: reduce)");
    setReduceMotion(mediaQuery === null || mediaQuery === void 0 ? void 0 : mediaQuery.matches);
    const listener = (event) => setReduceMotion(event.matches);
    (_b = mediaQuery === null || mediaQuery === void 0 ? void 0 : mediaQuery.addEventListener) === null || _b === void 0 ? void 0 : _b.call(mediaQuery, "change", listener);
    return () => {
      var _a2;
      return (_a2 = mediaQuery === null || mediaQuery === void 0 ? void 0 : mediaQuery.removeEventListener) === null || _a2 === void 0 ? void 0 : _a2.call(mediaQuery, "change", listener);
    };
  }, []);
  return reduceMotion;
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useAnimation.js
function currentTransformation(node) {
  let x = 0;
  let y = 0;
  let z = 0;
  const matrix = window.getComputedStyle(node).transform;
  const matcher = matrix.match(/matrix.*\((.+)\)/);
  if (matcher) {
    const values = matcher[1].split(",").map((str) => Number.parseInt(str, 10));
    if (values.length === 6) {
      x = values[4];
      y = values[5];
    } else if (values.length === 16) {
      x = values[12];
      y = values[13];
      z = values[14];
    }
  }
  return { x, y, z };
}
function useAnimation(nodeRef, computeAnimation) {
  const snapshot = React4.useRef();
  const animation = React4.useRef();
  const reduceMotion = useMotionPreference();
  useLayoutEffect2(() => {
    var _a, _b, _c;
    if (nodeRef.current && snapshot.current !== void 0 && !reduceMotion) {
      const { keyframes, duration, easing, onfinish } = computeAnimation(snapshot.current, nodeRef.current.getBoundingClientRect(), currentTransformation(nodeRef.current)) || {};
      if (keyframes && duration) {
        (_a = animation.current) === null || _a === void 0 ? void 0 : _a.cancel();
        animation.current = (_c = (_b = nodeRef.current).animate) === null || _c === void 0 ? void 0 : _c.call(_b, keyframes, { duration, easing });
        if (animation.current) {
          animation.current.onfinish = () => {
            animation.current = void 0;
            onfinish === null || onfinish === void 0 ? void 0 : onfinish();
          };
        }
      }
    }
    snapshot.current = void 0;
  });
  return (currentSnapshot) => {
    snapshot.current = currentSnapshot;
  };
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useContainerRect.js
var React5 = __toESM(require_react(), 1);
function useContainerRect() {
  const [containerRect, setContainerRect] = React5.useState();
  const containerRef = React5.useRef(null);
  const observerRef = React5.useRef();
  const setContainerRef = React5.useCallback((node) => {
    containerRef.current = node;
    if (observerRef.current) {
      observerRef.current.disconnect();
      observerRef.current = void 0;
    }
    const updateContainerRect = () => {
      if (node) {
        const styles = window.getComputedStyle(node);
        const parse = (value) => parseFloat(value) || 0;
        setContainerRect({
          width: Math.round(node.clientWidth - parse(styles.paddingLeft) - parse(styles.paddingRight)),
          height: Math.round(node.clientHeight - parse(styles.paddingTop) - parse(styles.paddingBottom))
        });
      } else {
        setContainerRect(void 0);
      }
    };
    updateContainerRect();
    if (node && typeof ResizeObserver !== "undefined") {
      observerRef.current = new ResizeObserver(updateContainerRect);
      observerRef.current.observe(node);
    }
  }, []);
  return React5.useMemo(() => ({
    setContainerRef,
    containerRef,
    containerRect
  }), [setContainerRef, containerRef, containerRect]);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useDelay.js
var React7 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/core/contexts/Timeouts.js
var React6 = __toESM(require_react(), 1);
var TimeoutsContext = React6.createContext(null);
var useTimeouts = makeUseContext("useTimeouts", "TimeoutsContext", TimeoutsContext);
function TimeoutsProvider({ children }) {
  const [timeouts] = React6.useState([]);
  React6.useEffect(() => () => {
    timeouts.forEach((tid) => window.clearTimeout(tid));
    timeouts.splice(0, timeouts.length);
  }, [timeouts]);
  const context = React6.useMemo(() => {
    const removeTimeout = (id) => {
      timeouts.splice(0, timeouts.length, ...timeouts.filter((tid) => tid !== id));
    };
    const setTimeout = (fn, delay) => {
      const id = window.setTimeout(() => {
        removeTimeout(id);
        fn();
      }, delay);
      timeouts.push(id);
      return id;
    };
    const clearTimeout = (id) => {
      if (isDefined(id)) {
        removeTimeout(id);
        window.clearTimeout(id);
      }
    };
    return { setTimeout, clearTimeout };
  }, [timeouts]);
  return React6.createElement(TimeoutsContext.Provider, { value: context }, children);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useDelay.js
function useDelay() {
  const timeoutId = React7.useRef();
  const { setTimeout, clearTimeout } = useTimeouts();
  return React7.useCallback((callback, delay) => {
    clearTimeout(timeoutId.current);
    timeoutId.current = setTimeout(callback, delay > 0 ? delay : 0);
  }, [setTimeout, clearTimeout]);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useEventCallback.js
var React8 = __toESM(require_react(), 1);
function useEventCallback(fn) {
  const ref = React8.useRef(fn);
  useLayoutEffect2(() => {
    ref.current = fn;
  });
  return React8.useCallback((...args) => {
    var _a;
    return (_a = ref.current) === null || _a === void 0 ? void 0 : _a.call(ref, ...args);
  }, []);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useForkRef.js
var React9 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function useForkRef(refA, refB) {
  return React9.useMemo(() => refA == null && refB == null ? null : (refValue) => {
    setRef(refA, refValue);
    setRef(refB, refValue);
  }, [refA, refB]);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useLoseFocus.js
var React10 = __toESM(require_react(), 1);
function useLoseFocus(disabled = false) {
  const focused = React10.useRef(disabled);
  const { transferFocus } = useController();
  useLayoutEffect2(() => {
    if (disabled) {
      transferFocus();
    }
  }, [disabled, transferFocus]);
  const onFocus = React10.useCallback(() => {
    focused.current = true;
  }, []);
  const onBlur = React10.useCallback(() => {
    focused.current = false;
  }, []);
  return { onFocus, onBlur };
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useRTL.js
var React11 = __toESM(require_react(), 1);
function useRTL() {
  const [isRTL, setIsRTL] = React11.useState(false);
  useLayoutEffect2(() => {
    setIsRTL(window.getComputedStyle(window.document.documentElement).direction === "rtl");
  }, []);
  return isRTL;
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useSensors.js
var React12 = __toESM(require_react(), 1);
function useSensors() {
  const [subscribers] = React12.useState({});
  return React12.useMemo(() => {
    const notifySubscribers = (type, event) => {
      var _a;
      (_a = subscribers[type]) === null || _a === void 0 ? void 0 : _a.forEach((listener) => {
        if (!event.isPropagationStopped())
          listener(event);
      });
    };
    return {
      registerSensors: {
        onPointerDown: (event) => notifySubscribers(EVENT_ON_POINTER_DOWN, event),
        onPointerMove: (event) => notifySubscribers(EVENT_ON_POINTER_MOVE, event),
        onPointerUp: (event) => notifySubscribers(EVENT_ON_POINTER_UP, event),
        onPointerLeave: (event) => notifySubscribers(EVENT_ON_POINTER_LEAVE, event),
        onPointerCancel: (event) => notifySubscribers(EVENT_ON_POINTER_CANCEL, event),
        onKeyDown: (event) => notifySubscribers(EVENT_ON_KEY_DOWN, event),
        onKeyUp: (event) => notifySubscribers(EVENT_ON_KEY_UP, event),
        onWheel: (event) => notifySubscribers(EVENT_ON_WHEEL, event)
      },
      subscribeSensors: (type, callback) => {
        if (!subscribers[type]) {
          subscribers[type] = [];
        }
        subscribers[type].unshift(callback);
        return () => {
          const listeners = subscribers[type];
          if (listeners) {
            listeners.splice(0, listeners.length, ...listeners.filter((el) => el !== callback));
          }
        };
      }
    };
  }, [subscribers]);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useThrottle.js
var React13 = __toESM(require_react(), 1);
function useThrottle(callback, delay) {
  const lastCallbackTime = React13.useRef(0);
  const delayCallback = useDelay();
  const executeCallback = useEventCallback((...args) => {
    lastCallbackTime.current = Date.now();
    callback(args);
  });
  return React13.useCallback((...args) => {
    delayCallback(() => {
      executeCallback(args);
    }, delay - (Date.now() - lastCallbackTime.current));
  }, [delay, executeCallback, delayCallback]);
}

// node_modules/yet-another-react-lightbox/dist/core/contexts/Events.js
var React14 = __toESM(require_react(), 1);
var EventsContext = React14.createContext(null);
var useEvents = makeUseContext("useEvents", "EventsContext", EventsContext);
function EventsProvider({ children }) {
  const [subscriptions] = React14.useState({});
  React14.useEffect(() => () => {
    Object.keys(subscriptions).forEach((key) => delete subscriptions[key]);
  }, [subscriptions]);
  const context = React14.useMemo(() => {
    const unsubscribe = (topic, callback) => {
      var _a;
      (_a = subscriptions[topic]) === null || _a === void 0 ? void 0 : _a.splice(0, subscriptions[topic].length, ...subscriptions[topic].filter((cb) => cb !== callback));
    };
    const subscribe = (topic, callback) => {
      if (!subscriptions[topic]) {
        subscriptions[topic] = [];
      }
      subscriptions[topic].push(callback);
      return () => unsubscribe(topic, callback);
    };
    const publish = (topic, event) => {
      var _a;
      (_a = subscriptions[topic]) === null || _a === void 0 ? void 0 : _a.forEach((callback) => callback(event));
    };
    return { publish, subscribe, unsubscribe };
  }, [subscriptions]);
  return React14.createElement(EventsContext.Provider, { value: context }, children);
}

// node_modules/yet-another-react-lightbox/dist/core/contexts/LightboxState.js
var React15 = __toESM(require_react(), 1);
var LightboxStateContext = React15.createContext(null);
var useLightboxState = makeUseContext("useLightboxState", "LightboxStateContext", LightboxStateContext);
var reducer = (slidesCount) => (state, action) => {
  const increment = (action === null || action === void 0 ? void 0 : action.increment) || 0;
  const globalIndex = state.globalIndex + increment;
  const currentIndex = getSlideIndex(globalIndex, slidesCount);
  const animationDuration = (action === null || action === void 0 ? void 0 : action.duration) || 0;
  return {
    globalIndex,
    currentIndex,
    animation: action,
    animationDuration
  };
};
function LightboxStateProvider({ initialIndex, slidesCount, children }) {
  const memoizedReducer = React15.useMemo(() => reducer(slidesCount), [slidesCount]);
  const [state, dispatch] = React15.useReducer(memoizedReducer, {
    currentIndex: initialIndex,
    globalIndex: initialIndex,
    animationDuration: 0
  });
  const context = React15.useMemo(() => ({ state, dispatch }), [state, dispatch]);
  return React15.createElement(LightboxStateContext.Provider, { value: context }, children);
}

// node_modules/yet-another-react-lightbox/dist/core/modules/controller/usePointerSwipe.js
var React16 = __toESM(require_react(), 1);
function usePointerSwipe(subscribeSensors, isSwipeValid, containerWidth, swipeAnimationDuration, onSwipeStart, onSwipeProgress, onSwipeFinish, onSwipeCancel) {
  const offset = React16.useRef(0);
  const pointers = React16.useRef([]);
  const activePointer = React16.useRef();
  const startTime = React16.useRef(0);
  const clearPointer = React16.useCallback((event) => {
    if (activePointer.current === event.pointerId) {
      activePointer.current = void 0;
    }
    const currentPointers = pointers.current;
    currentPointers.splice(0, currentPointers.length, ...currentPointers.filter((p) => p.pointerId !== event.pointerId));
  }, []);
  const addPointer = React16.useCallback((event) => {
    clearPointer(event);
    event.persist();
    pointers.current.push(event);
  }, [clearPointer]);
  const onPointerDown = useEventCallback((event) => {
    addPointer(event);
  });
  const onPointerUp = useEventCallback((event) => {
    if (pointers.current.find((x) => x.pointerId === event.pointerId) && activePointer.current === event.pointerId) {
      const duration = Date.now() - startTime.current;
      const currentOffset = offset.current;
      if (Math.abs(currentOffset) > 0.3 * containerWidth || Math.abs(currentOffset) > 5 && duration < swipeAnimationDuration) {
        onSwipeFinish(currentOffset, duration);
      } else {
        onSwipeCancel(currentOffset);
      }
      offset.current = 0;
    }
    clearPointer(event);
  });
  const onPointerMove = useEventCallback((event) => {
    const pointer = pointers.current.find((p) => p.pointerId === event.pointerId);
    if (pointer) {
      const isCurrentPointer = activePointer.current === event.pointerId;
      if (event.buttons === 0) {
        if (isCurrentPointer && offset.current !== 0) {
          onPointerUp(event);
        } else {
          clearPointer(pointer);
        }
        return;
      }
      const deltaX = event.clientX - pointer.clientX;
      const deltaY = event.clientY - pointer.clientY;
      if (activePointer.current === void 0 && isSwipeValid(deltaX) && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
        addPointer(event);
        activePointer.current = event.pointerId;
        startTime.current = Date.now();
        onSwipeStart();
      } else if (isCurrentPointer) {
        offset.current = deltaX;
        onSwipeProgress(deltaX);
      }
    }
  });
  React16.useEffect(() => cleanup(subscribeSensors(EVENT_ON_POINTER_DOWN, onPointerDown), subscribeSensors(EVENT_ON_POINTER_MOVE, onPointerMove), subscribeSensors(EVENT_ON_POINTER_UP, onPointerUp), subscribeSensors(EVENT_ON_POINTER_LEAVE, onPointerUp), subscribeSensors(EVENT_ON_POINTER_CANCEL, onPointerUp)), [subscribeSensors, onPointerDown, onPointerMove, onPointerUp]);
}

// node_modules/yet-another-react-lightbox/dist/core/modules/controller/usePreventSwipeNavigation.js
var React17 = __toESM(require_react(), 1);
var WHEEL = "wheel";
function preventDefault(event) {
  if (Math.abs(event.deltaX) > Math.abs(event.deltaY) || event.ctrlKey) {
    event.preventDefault();
  }
}
function usePreventSwipeNavigation() {
  const ref = React17.useRef(null);
  return React17.useCallback((node) => {
    var _a;
    if (node) {
      node.addEventListener(WHEEL, preventDefault, { passive: false });
    } else {
      (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(WHEEL, preventDefault);
    }
    ref.current = node;
  }, []);
}

// node_modules/yet-another-react-lightbox/dist/core/modules/controller/useWheelSwipe.js
var React18 = __toESM(require_react(), 1);
function useWheelSwipe(swipeState, subscribeSensors, isSwipeValid, containerWidth, swipeAnimationDuration, onSwipeStart, onSwipeProgress, onSwipeFinish, onSwipeCancel) {
  const offset = React18.useRef(0);
  const intent = React18.useRef(0);
  const intentCleanup = React18.useRef();
  const resetCleanup = React18.useRef();
  const wheelResidualMomentum = React18.useRef(0);
  const startTime = React18.useRef(0);
  const { setTimeout, clearTimeout } = useTimeouts();
  const cancelSwipeIntentCleanup = React18.useCallback(() => {
    if (intentCleanup.current) {
      clearTimeout(intentCleanup.current);
      intentCleanup.current = void 0;
    }
  }, [clearTimeout]);
  const cancelSwipeResetCleanup = React18.useCallback(() => {
    if (resetCleanup.current) {
      clearTimeout(resetCleanup.current);
      resetCleanup.current = void 0;
    }
  }, [clearTimeout]);
  const handleCleanup = useEventCallback(() => {
    if (swipeState !== SwipeState.SWIPE) {
      offset.current = 0;
      startTime.current = 0;
      cancelSwipeIntentCleanup();
      cancelSwipeResetCleanup();
    }
  });
  React18.useEffect(handleCleanup, [swipeState, handleCleanup]);
  const handleCancelSwipe = useEventCallback((currentSwipeOffset) => {
    resetCleanup.current = void 0;
    if (offset.current === currentSwipeOffset) {
      onSwipeCancel(offset.current);
    }
  });
  const onWheel = useEventCallback((event) => {
    if (event.ctrlKey) {
      return;
    }
    if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {
      return;
    }
    if (!swipeState) {
      if (Math.abs(event.deltaX) <= 1.2 * Math.abs(wheelResidualMomentum.current)) {
        wheelResidualMomentum.current = event.deltaX;
        return;
      }
      if (!isSwipeValid(-event.deltaX)) {
        return;
      }
      intent.current += event.deltaX;
      cancelSwipeIntentCleanup();
      if (Math.abs(intent.current) > 30) {
        intent.current = 0;
        wheelResidualMomentum.current = 0;
        startTime.current = Date.now();
        onSwipeStart();
      } else {
        const currentSwipeIntent = intent.current;
        intentCleanup.current = setTimeout(() => {
          intentCleanup.current = void 0;
          if (currentSwipeIntent === intent.current) {
            intent.current = 0;
          }
        }, swipeAnimationDuration);
      }
    } else if (swipeState === SwipeState.SWIPE) {
      let newSwipeOffset = offset.current - event.deltaX;
      newSwipeOffset = Math.min(Math.abs(newSwipeOffset), containerWidth) * Math.sign(newSwipeOffset);
      offset.current = newSwipeOffset;
      onSwipeProgress(newSwipeOffset);
      cancelSwipeResetCleanup();
      if (Math.abs(newSwipeOffset) > 0.2 * containerWidth) {
        wheelResidualMomentum.current = event.deltaX;
        onSwipeFinish(newSwipeOffset, Date.now() - startTime.current);
        return;
      }
      resetCleanup.current = setTimeout(() => handleCancelSwipe(newSwipeOffset), 2 * swipeAnimationDuration);
    } else {
      wheelResidualMomentum.current = event.deltaX;
    }
  });
  React18.useEffect(() => subscribeSensors(EVENT_ON_WHEEL, onWheel), [subscribeSensors, onWheel]);
}

// node_modules/yet-another-react-lightbox/dist/core/modules/controller/index.js
var SwipeState;
(function(SwipeState2) {
  SwipeState2[SwipeState2["NONE"] = 0] = "NONE";
  SwipeState2[SwipeState2["SWIPE"] = 1] = "SWIPE";
  SwipeState2[SwipeState2["ANIMATION"] = 2] = "ANIMATION";
})(SwipeState || (SwipeState = {}));

// node_modules/yet-another-react-lightbox/dist/core/modules/Controller.js
var cssContainerPrefix = makeComposePrefix("container");
var ControllerContext = React19.createContext(null);
var useController = makeUseContext("useController", "ControllerContext", ControllerContext);
function Controller({ children, ...props }) {
  const { carousel, slides, animation, controller, on, styles } = props;
  const { state, dispatch } = useLightboxState();
  const [swipeState, setSwipeState] = React19.useState(SwipeState.NONE);
  const swipeOffset = React19.useRef(0);
  const { registerSensors, subscribeSensors } = useSensors();
  const { subscribe, publish } = useEvents();
  const cleanupAnimationIncrement = useDelay();
  const cleanupSwipeOffset = useDelay();
  const { containerRef, setContainerRef, containerRect } = useContainerRect();
  const handleContainerRef = useForkRef(usePreventSwipeNavigation(), setContainerRef);
  const carouselRef = React19.useRef(null);
  const setCarouselRef = useForkRef(carouselRef, void 0);
  const isRTL = useRTL();
  const rtl = (value) => (isRTL ? -1 : 1) * (isNumber(value) ? value : 1);
  const isSwipeValid = (offset) => !(carousel.finite && (rtl(offset) > 0 && state.currentIndex === 0 || rtl(offset) < 0 && state.currentIndex === slides.length - 1));
  const setSwipeOffset = (offset) => {
    var _a;
    swipeOffset.current = offset;
    (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.style.setProperty(cssVar("swipe_offset"), `${Math.round(offset)}px`);
  };
  const animate = useAnimation(carouselRef, (snapshot, rect, translate) => {
    var _a;
    if (carouselRef.current && containerRect && ((_a = state.animation) === null || _a === void 0 ? void 0 : _a.duration)) {
      const parsedSpacing = parseLengthPercentage(carousel.spacing);
      const spacingValue = (parsedSpacing.percent ? parsedSpacing.percent * containerRect.width / 100 : parsedSpacing.pixel) || 0;
      return {
        keyframes: [
          {
            transform: `translateX(${rtl(state.globalIndex - snapshot.index) * (containerRect.width + spacingValue) + snapshot.rect.x - rect.x + translate.x}px)`
          },
          { transform: "translateX(0)" }
        ],
        duration: state.animation.duration,
        easing: state.animation.easing
      };
    }
    return void 0;
  });
  const swipe = useEventCallback((action) => {
    var _a;
    const currentSwipeOffset = action.offset || 0;
    const swipeDuration = !currentSwipeOffset ? getNavigationAnimationDuration(animation) : getSwipeAnimationDuration(animation);
    const swipeEasing = getAnimationEasing(!currentSwipeOffset ? animation.navigation : animation.swipe);
    let { direction } = action;
    const count = (_a = action.count) !== null && _a !== void 0 ? _a : 1;
    let newSwipeState = SwipeState.ANIMATION;
    let newSwipeAnimationDuration = swipeDuration * count;
    if (!direction) {
      const containerWidth = containerRect === null || containerRect === void 0 ? void 0 : containerRect.width;
      const elapsedTime = action.duration || 0;
      const expectedTime = containerWidth ? swipeDuration / containerWidth * Math.abs(currentSwipeOffset) : swipeDuration;
      if (count !== 0) {
        if (elapsedTime < expectedTime) {
          newSwipeAnimationDuration = newSwipeAnimationDuration / expectedTime * Math.max(elapsedTime, expectedTime / 5);
        } else if (containerWidth) {
          newSwipeAnimationDuration = swipeDuration / containerWidth * (containerWidth - Math.abs(currentSwipeOffset));
        }
        direction = rtl(currentSwipeOffset) > 0 ? ACTION_PREV : ACTION_NEXT;
      } else {
        newSwipeAnimationDuration = swipeDuration / 2;
      }
    }
    let increment = 0;
    if (direction === ACTION_PREV) {
      if (isSwipeValid(rtl(1))) {
        increment = -count;
      } else {
        newSwipeState = SwipeState.NONE;
        newSwipeAnimationDuration = swipeDuration;
      }
    } else if (direction === ACTION_NEXT) {
      if (isSwipeValid(rtl(-1))) {
        increment = count;
      } else {
        newSwipeState = SwipeState.NONE;
        newSwipeAnimationDuration = swipeDuration;
      }
    }
    newSwipeAnimationDuration = Math.round(newSwipeAnimationDuration);
    cleanupSwipeOffset(() => {
      setSwipeOffset(0);
      setSwipeState(SwipeState.NONE);
    }, newSwipeAnimationDuration);
    if (carouselRef.current) {
      animate({
        rect: carouselRef.current.getBoundingClientRect(),
        index: state.globalIndex
      });
    }
    setSwipeState(newSwipeState);
    publish(ACTION_SWIPE, { increment, duration: newSwipeAnimationDuration, easing: swipeEasing });
  });
  React19.useEffect(() => {
    var _a, _b;
    if (((_a = state.animation) === null || _a === void 0 ? void 0 : _a.increment) && ((_b = state.animation) === null || _b === void 0 ? void 0 : _b.duration)) {
      cleanupAnimationIncrement(() => dispatch({ increment: 0 }), state.animation.duration);
    }
  }, [state.animation, dispatch, cleanupAnimationIncrement]);
  const swipeParams = [
    subscribeSensors,
    isSwipeValid,
    (containerRect === null || containerRect === void 0 ? void 0 : containerRect.width) || 0,
    getSwipeAnimationDuration(animation),
    () => setSwipeState(SwipeState.SWIPE),
    (offset) => setSwipeOffset(offset),
    (offset, duration) => swipe({ offset, duration, count: 1 }),
    (offset) => swipe({ offset, count: 0 })
  ];
  usePointerSwipe(...swipeParams);
  useWheelSwipe(swipeState, ...swipeParams);
  const focusOnMount = useEventCallback(() => {
    var _a;
    if (controller.focus) {
      (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  });
  React19.useEffect(focusOnMount, [focusOnMount]);
  const handleIndexChange = useEventCallback(() => {
    var _a;
    (_a = on.view) === null || _a === void 0 ? void 0 : _a.call(on, state.currentIndex);
  });
  React19.useEffect(handleIndexChange, [state.currentIndex, handleIndexChange]);
  React19.useEffect(() => cleanup(subscribe(ACTION_PREV, (action) => swipe({ direction: ACTION_PREV, ...action })), subscribe(ACTION_NEXT, (action) => swipe({ direction: ACTION_NEXT, ...action })), subscribe(ACTION_SWIPE, (action) => dispatch(action))), [subscribe, swipe, dispatch]);
  React19.useEffect(() => subscribeSensors(EVENT_ON_KEY_UP, (event) => {
    if (event.code === VK_ESCAPE) {
      publish(ACTION_CLOSE);
    }
  }), [subscribeSensors, publish]);
  React19.useEffect(() => controller.closeOnBackdropClick ? subscribe(YARL_EVENT_BACKDROP_CLICK, () => publish(ACTION_CLOSE)) : () => {
  }, [controller.closeOnBackdropClick, publish, subscribe]);
  const transferFocus = useEventCallback(() => {
    var _a;
    return (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
  });
  const getLightboxProps = useEventCallback(() => props);
  const context = React19.useMemo(() => ({
    getLightboxProps,
    subscribeSensors,
    transferFocus,
    containerRect: containerRect || { width: 0, height: 0 },
    containerRef,
    setCarouselRef
  }), [getLightboxProps, subscribeSensors, transferFocus, containerRect, containerRef, setCarouselRef]);
  return React19.createElement("div", { ref: handleContainerRef, className: clsx(cssClass(cssContainerPrefix()), cssClass(CLASS_FLEX_CENTER)), style: {
    ...swipeState === SwipeState.SWIPE ? { [cssVar("swipe_offset")]: `${Math.round(swipeOffset.current)}px` } : null,
    ...controller.touchAction !== "none" ? { [cssVar("controller_touch_action")]: controller.touchAction } : null,
    ...styles.container
  }, ...controller.aria ? { role: "presentation", "aria-live": "polite" } : null, tabIndex: -1, ...registerSensors }, containerRect && React19.createElement(ControllerContext.Provider, { value: context }, children));
}
var ControllerModule = createModule(MODULE_CONTROLLER, Controller);

// node_modules/yet-another-react-lightbox/dist/core/modules/Carousel.js
var React23 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/core/components/IconButton.js
var React20 = __toESM(require_react(), 1);
var IconButton = React20.forwardRef(({ label: label2, className, icon: Icon, renderIcon, onClick, style, ...rest }, ref) => {
  const { styles } = useController().getLightboxProps();
  return React20.createElement("button", { ref, type: "button", "aria-label": label2, className: clsx(cssClass(ELEMENT_BUTTON), className), onClick, style: { ...style, ...styles.button }, ...rest }, renderIcon ? renderIcon() : React20.createElement(Icon, { className: cssClass(ELEMENT_ICON), style: styles.icon }));
});
IconButton.displayName = "IconButton";

// node_modules/yet-another-react-lightbox/dist/core/components/Icons.js
var React21 = __toESM(require_react(), 1);
function createIcon(name, glyph) {
  const icon = (props) => React21.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24", "aria-hidden": "true", focusable: "false", ...props },
    React21.createElement(
      "g",
      { fill: "currentColor" },
      React21.createElement("path", { d: "M0 0h24v24H0z", fill: "none" }),
      glyph
    )
  );
  icon.displayName = name;
  return icon;
}
var CloseIcon = createIcon("Close", React21.createElement("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }));
var PreviousIcon = createIcon("Previous", React21.createElement("path", { d: "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" }));
var NextIcon = createIcon("Next", React21.createElement("path", { d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" }));
var LoadingIcon = createIcon("Loading", React21.createElement(React21.Fragment, null, Array.from({ length: 8 }).map((_, index, array) => React21.createElement("line", { key: index, x1: "12", y1: "6.5", x2: "12", y2: "1.8", strokeLinecap: "round", strokeWidth: "2.6", stroke: "currentColor", strokeOpacity: 1 / array.length * (index + 1), transform: `rotate(${360 / array.length * index}, 12, 12)` }))));
var ErrorIcon = createIcon("Error", React21.createElement("path", { d: "M21.9,21.9l-8.49-8.49l0,0L3.59,3.59l0,0L2.1,2.1L0.69,3.51L3,5.83V19c0,1.1,0.9,2,2,2h13.17l2.31,2.31L21.9,21.9z M5,18 l3.5-4.5l2.5,3.01L12.17,15l3,3H5z M21,18.17L5.83,3H19c1.1,0,2,0.9,2,2V18.17z" }));

// node_modules/yet-another-react-lightbox/dist/core/components/ImageSlide.js
var React22 = __toESM(require_react(), 1);
var slidePrefix = makeComposePrefix("slide");
var slideImagePrefix = makeComposePrefix("slide_image");
function ImageSlide({ slide: image, offset, render, rect, imageFit, onClick, onLoad, style }) {
  var _a, _b, _c, _d, _e, _f, _g;
  const [status, setStatus] = React22.useState(SLIDE_STATUS_LOADING);
  const { publish } = useEvents();
  const { setTimeout } = useTimeouts();
  const imageRef = React22.useRef(null);
  React22.useEffect(() => {
    if (offset === 0) {
      publish(activeSlideStatus(status));
    }
  }, [offset, status, publish]);
  const handleLoading = useEventCallback((img) => {
    if (status === SLIDE_STATUS_COMPLETE) {
      return;
    }
    ("decode" in img ? img.decode() : Promise.resolve()).catch(() => {
    }).then(() => {
      if (!img.parentNode) {
        return;
      }
      setStatus(SLIDE_STATUS_COMPLETE);
      setTimeout(() => {
        onLoad === null || onLoad === void 0 ? void 0 : onLoad(img);
      }, 0);
    });
  });
  const setImageRef = React22.useCallback((img) => {
    imageRef.current = img;
    if (img === null || img === void 0 ? void 0 : img.complete) {
      handleLoading(img);
    }
  }, [handleLoading]);
  const handleOnLoad = React22.useCallback((event) => {
    handleLoading(event.currentTarget);
  }, [handleLoading]);
  const onError = React22.useCallback(() => {
    setStatus(SLIDE_STATUS_ERROR);
  }, []);
  const cover = image.imageFit === IMAGE_FIT_COVER || image.imageFit !== IMAGE_FIT_CONTAIN && imageFit === IMAGE_FIT_COVER;
  const nonInfinite = (value, fallback) => Number.isFinite(value) ? value : fallback;
  const maxWidth = nonInfinite(Math.max(...((_b = (_a = image.srcSet) === null || _a === void 0 ? void 0 : _a.map((x) => x.width)) !== null && _b !== void 0 ? _b : []).concat(image.width ? [image.width] : [])), ((_c = imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalWidth) || 0);
  const maxHeight = nonInfinite(Math.max(...((_e = (_d = image.srcSet) === null || _d === void 0 ? void 0 : _d.map((x) => x.height)) !== null && _e !== void 0 ? _e : []).concat(image.height ? [image.height] : [])), ((_f = imageRef.current) === null || _f === void 0 ? void 0 : _f.naturalHeight) || 0);
  const defaultStyle = maxWidth && maxHeight ? {
    maxWidth: `min(${maxWidth}px, 100%)`,
    maxHeight: `min(${maxHeight}px, 100%)`
  } : {
    maxWidth: "100%",
    maxHeight: "100%"
  };
  const srcSet = (_g = image.srcSet) === null || _g === void 0 ? void 0 : _g.sort((a, b) => a.width - b.width).map((item) => `${item.src} ${item.width}w`).join(", ");
  const estimateActualWidth = () => rect && !cover && image.width && image.height ? rect.height / image.height * image.width : Number.MAX_VALUE;
  const sizes = srcSet && rect && hasWindow() ? `${Math.round(Math.min(estimateActualWidth(), rect.width))}px` : void 0;
  return React22.createElement(
    React22.Fragment,
    null,
    React22.createElement("img", { ref: setImageRef, onLoad: handleOnLoad, onError, onClick, className: clsx(cssClass(slideImagePrefix()), cover && cssClass(slideImagePrefix("cover")), status !== SLIDE_STATUS_COMPLETE && cssClass(slideImagePrefix("loading"))), draggable: false, alt: image.alt, style: { ...defaultStyle, ...style }, sizes, srcSet, src: image.src }),
    status !== SLIDE_STATUS_COMPLETE && React22.createElement(
      "div",
      { className: cssClass(slidePrefix(SLIDE_STATUS_PLACEHOLDER)) },
      status === SLIDE_STATUS_LOADING && ((render === null || render === void 0 ? void 0 : render.iconLoading) ? render.iconLoading() : React22.createElement(LoadingIcon, { className: clsx(cssClass(ELEMENT_ICON), cssClass(slidePrefix(SLIDE_STATUS_LOADING))) })),
      status === SLIDE_STATUS_ERROR && ((render === null || render === void 0 ? void 0 : render.iconError) ? render.iconError() : React22.createElement(ErrorIcon, { className: clsx(cssClass(ELEMENT_ICON), cssClass(slidePrefix(SLIDE_STATUS_ERROR))) }))
    )
  );
}

// node_modules/yet-another-react-lightbox/dist/core/modules/Carousel.js
function cssPrefix2(value) {
  return composePrefix(MODULE_CAROUSEL, value);
}
function cssSlidePrefix(value) {
  return composePrefix("slide", value);
}
function CarouselSlide({ slide, offset, rect }) {
  const containerRef = React23.useRef(null);
  const { publish } = useEvents();
  const { currentIndex } = useLightboxState().state;
  const { render, carousel: { imageFit }, on: { click: onClick } } = useController().getLightboxProps();
  const renderSlide = () => {
    var _a, _b, _c, _d;
    let rendered = (_a = render.slide) === null || _a === void 0 ? void 0 : _a.call(render, slide, offset, rect);
    if (!rendered && isImageSlide(slide)) {
      rendered = React23.createElement(ImageSlide, { slide, offset, render, rect, imageFit, onClick: offset === 0 ? () => onClick === null || onClick === void 0 ? void 0 : onClick(currentIndex) : void 0 });
    }
    return rendered ? React23.createElement(
      React23.Fragment,
      null,
      (_b = render.slideHeader) === null || _b === void 0 ? void 0 : _b.call(render, slide),
      ((_c = render.slideContainer) !== null && _c !== void 0 ? _c : (_, x) => x)(slide, rendered),
      (_d = render.slideFooter) === null || _d === void 0 ? void 0 : _d.call(render, slide)
    ) : null;
  };
  const handleBackdropClick = (event) => {
    const container = containerRef.current;
    const target = event.target instanceof HTMLElement ? event.target : void 0;
    if (target && container && (target === container || Array.from(container.children).find((x) => x === target) && target.classList.contains(cssClass(CLASS_FULLSIZE)))) {
      publish(YARL_EVENT_BACKDROP_CLICK);
    }
  };
  return React23.createElement("div", { ref: containerRef, className: clsx(cssClass(cssSlidePrefix()), offset === 0 && cssClass(cssSlidePrefix("current")), cssClass(CLASS_FLEX_CENTER)), onClick: handleBackdropClick }, renderSlide());
}
function Placeholder() {
  return React23.createElement("div", { className: cssClass("slide") });
}
function Carousel({ slides, carousel: { finite, preload, padding, spacing } }) {
  const { currentIndex, globalIndex } = useLightboxState().state;
  const { setCarouselRef, containerRect } = useController();
  const spacingValue = parseLengthPercentage(spacing);
  const paddingValue = parseLengthPercentage(padding);
  const paddingPixels = paddingValue.percent !== void 0 ? containerRect.width / 100 * paddingValue.percent : paddingValue.pixel;
  const rect = {
    width: Math.max(containerRect.width - 2 * paddingPixels, 0),
    height: Math.max(containerRect.height - 2 * paddingPixels, 0)
  };
  const items = [];
  if ((slides === null || slides === void 0 ? void 0 : slides.length) > 0) {
    for (let i = currentIndex - preload; i < currentIndex; i += 1) {
      const key = globalIndex + i - currentIndex;
      items.push(!finite || i >= 0 ? React23.createElement(CarouselSlide, { key, slide: slides[(i + preload * slides.length) % slides.length], rect, offset: i - currentIndex }) : React23.createElement(Placeholder, { key }));
    }
    items.push(React23.createElement(CarouselSlide, { key: globalIndex, slide: slides[currentIndex], rect, offset: 0 }));
    for (let i = currentIndex + 1; i <= currentIndex + preload; i += 1) {
      const key = globalIndex + i - currentIndex;
      items.push(!finite || i <= slides.length - 1 ? React23.createElement(CarouselSlide, { key, slide: slides[i % slides.length], rect, offset: i - currentIndex }) : React23.createElement(Placeholder, { key }));
    }
  }
  return React23.createElement("div", { ref: setCarouselRef, className: clsx(cssClass(cssPrefix2()), items.length > 0 && cssClass(cssPrefix2("with_slides"))), style: {
    [`${cssVar(cssPrefix2("slides_count"))}`]: items.length,
    [`${cssVar(cssPrefix2("spacing_px"))}`]: spacingValue.pixel || 0,
    [`${cssVar(cssPrefix2("spacing_percent"))}`]: spacingValue.percent || 0,
    [`${cssVar(cssPrefix2("padding_px"))}`]: paddingValue.pixel || 0,
    [`${cssVar(cssPrefix2("padding_percent"))}`]: paddingValue.percent || 0
  } }, items);
}
var CarouselModule = createModule(MODULE_CAROUSEL, Carousel);

// node_modules/yet-another-react-lightbox/dist/core/modules/Core.js
var React24 = __toESM(require_react(), 1);
function Core({ slides, index, children }) {
  return React24.createElement(
    TimeoutsProvider,
    null,
    React24.createElement(
      EventsProvider,
      null,
      React24.createElement(LightboxStateProvider, { slidesCount: slides.length, initialIndex: index }, children)
    )
  );
}
var CoreModule = createModule(MODULE_CORE, Core);

// node_modules/yet-another-react-lightbox/dist/core/modules/Navigation.js
var React25 = __toESM(require_react(), 1);
function NavigationButton({ labels, label: label2, icon, renderIcon, action, onClick, disabled }) {
  return React25.createElement(IconButton, { label: label(labels, label2), icon, renderIcon, className: cssClass(`navigation_${action}`), disabled, onClick, ...useLoseFocus(disabled) });
}
function Navigation({ slides, carousel: { finite }, animation, labels, render: { buttonPrev, buttonNext, iconPrev, iconNext } }) {
  const { currentIndex } = useLightboxState().state;
  const { subscribeSensors } = useController();
  const { publish } = useEvents();
  const isRTL = useRTL();
  const prevDisabled = slides.length === 0 || finite && currentIndex === 0;
  const nextDisabled = slides.length === 0 || finite && currentIndex === slides.length - 1;
  const publishThrottled = useThrottle((action) => publish(action), getNavigationAnimationDuration(animation) / 2);
  const handleKeyDown = useEventCallback((event) => {
    if (event.key === VK_ARROW_LEFT && !(isRTL ? nextDisabled : prevDisabled)) {
      publishThrottled(isRTL ? ACTION_NEXT : ACTION_PREV);
    }
    if (event.key === VK_ARROW_RIGHT && !(isRTL ? prevDisabled : nextDisabled)) {
      publishThrottled(isRTL ? ACTION_PREV : ACTION_NEXT);
    }
  });
  React25.useEffect(() => subscribeSensors(EVENT_ON_KEY_DOWN, handleKeyDown), [subscribeSensors, handleKeyDown]);
  return React25.createElement(
    React25.Fragment,
    null,
    buttonPrev ? buttonPrev() : React25.createElement(NavigationButton, { label: "Previous", action: ACTION_PREV, icon: PreviousIcon, renderIcon: iconPrev, disabled: prevDisabled, labels, onClick: () => publish(ACTION_PREV) }),
    buttonNext ? buttonNext() : React25.createElement(NavigationButton, { label: "Next", action: ACTION_NEXT, icon: NextIcon, renderIcon: iconNext, disabled: nextDisabled, labels, onClick: () => publish(ACTION_NEXT) })
  );
}
var NavigationModule = createModule(MODULE_NAVIGATION, Navigation);

// node_modules/yet-another-react-lightbox/dist/core/modules/NoScroll.js
var React26 = __toESM(require_react(), 1);
var noScroll = cssClass(CLASS_NO_SCROLL);
var noScrollPadding = cssClass(CLASS_NO_SCROLL_PADDING);
function isHTMLElement(element) {
  return "style" in element;
}
function padScrollbar(element, padding, rtl) {
  const styles = window.getComputedStyle(element);
  const property = rtl ? "padding-left" : "padding-right";
  const computedValue = rtl ? styles.paddingLeft : styles.paddingRight;
  const originalValue = element.style.getPropertyValue(property);
  element.style.setProperty(property, `${(parseInt(computedValue, 10) || 0) + padding}px`);
  return () => {
    if (originalValue) {
      element.style.setProperty(property, originalValue);
    } else {
      element.style.removeProperty(property);
    }
  };
}
function NoScroll({ children }) {
  const rtl = useRTL();
  useLayoutEffect2(() => {
    const cleanup2 = [];
    const { body, documentElement } = document;
    const scrollbar = Math.round(window.innerWidth - documentElement.clientWidth);
    if (scrollbar > 0) {
      cleanup2.push(padScrollbar(body, scrollbar, rtl));
      const elements = body.getElementsByTagName("*");
      for (let i = 0; i < elements.length; i += 1) {
        const element = elements[i];
        if (isHTMLElement(element) && window.getComputedStyle(element).getPropertyValue("position") === "fixed" && !element.classList.contains(noScrollPadding)) {
          cleanup2.push(padScrollbar(element, scrollbar, rtl));
        }
      }
    }
    body.classList.add(noScroll);
    return () => {
      body.classList.remove(noScroll);
      cleanup2.forEach((clean) => clean());
    };
  }, [rtl]);
  return React26.createElement(React26.Fragment, null, children);
}
var NoScrollModule = createModule(MODULE_NO_SCROLL, NoScroll);

// node_modules/yet-another-react-lightbox/dist/core/modules/Portal.js
var React27 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
function cssPrefix3(value) {
  return composePrefix(MODULE_PORTAL, value);
}
function setAttribute(element, attribute, value) {
  const previousValue = element.getAttribute(attribute);
  element.setAttribute(attribute, value);
  return () => {
    if (previousValue) {
      element.setAttribute(attribute, previousValue);
    } else {
      element.removeAttribute(attribute);
    }
  };
}
function Portal({ children, animation, styles, className, on, close }) {
  const [mounted, setMounted] = React27.useState(false);
  const [visible, setVisible] = React27.useState(false);
  const cleanup2 = React27.useRef([]);
  const { setTimeout } = useTimeouts();
  const { subscribe } = useEvents();
  const reduceMotion = useMotionPreference();
  const animationDuration = !reduceMotion ? getFadeAnimationDuration(animation) : 0;
  const animationEasing = !reduceMotion ? getAnimationEasing(animation.fade) : void 0;
  React27.useEffect(() => {
    setMounted(true);
    return () => {
      setMounted(false);
      setVisible(false);
    };
  }, []);
  const handleClose = useEventCallback(() => {
    var _a;
    setVisible(false);
    (_a = on.exiting) === null || _a === void 0 ? void 0 : _a.call(on);
    setTimeout(() => {
      var _a2;
      (_a2 = on.exited) === null || _a2 === void 0 ? void 0 : _a2.call(on);
      close();
    }, animationDuration);
  });
  React27.useEffect(() => subscribe(ACTION_CLOSE, handleClose), [subscribe, handleClose]);
  const handleEnter = useEventCallback((node) => {
    var _a, _b, _c;
    node.scrollTop;
    setVisible(true);
    (_a = on.entering) === null || _a === void 0 ? void 0 : _a.call(on);
    const elements = (_c = (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.children) !== null && _c !== void 0 ? _c : [];
    for (let i = 0; i < elements.length; i += 1) {
      const element = elements[i];
      if (["TEMPLATE", "SCRIPT", "STYLE"].indexOf(element.tagName) === -1 && element !== node) {
        cleanup2.current.push(setAttribute(element, "inert", "true"));
        cleanup2.current.push(setAttribute(element, "aria-hidden", "true"));
      }
    }
    setTimeout(() => {
      var _a2;
      (_a2 = on.entered) === null || _a2 === void 0 ? void 0 : _a2.call(on);
    }, animationDuration);
  });
  const handleExit = useEventCallback(() => {
    cleanup2.current.forEach((clean) => clean());
    cleanup2.current = [];
  });
  const handleRef = React27.useCallback((node) => {
    if (node) {
      handleEnter(node);
    } else {
      handleExit();
    }
  }, [handleEnter, handleExit]);
  return mounted ? ReactDOM.createPortal(React27.createElement("div", { ref: handleRef, className: clsx(className, cssClass("root"), cssClass(cssPrefix3()), cssClass(CLASS_NO_SCROLL_PADDING), visible && cssClass(cssPrefix3("open"))), role: "presentation", "aria-live": "polite", style: {
    ...animation.fade !== LightboxDefaultProps.animation.fade ? { [cssVar("fade_animation_duration")]: `${animationDuration}ms` } : null,
    ...animationEasing ? { [cssVar("fade_animation_timing_function")]: animationEasing } : null,
    ...styles.root
  } }, children), document.body) : null;
}
var PortalModule = createModule(MODULE_PORTAL, Portal);

// node_modules/yet-another-react-lightbox/dist/core/modules/Toolbar.js
var React28 = __toESM(require_react(), 1);
function cssPrefix4(value) {
  return composePrefix(MODULE_TOOLBAR, value);
}
function Toolbar({ toolbar: { buttons }, labels, render: { buttonClose, iconClose } }) {
  const { publish } = useEvents();
  const { setContainerRef, containerRect } = useContainerRect();
  React28.useEffect(() => {
    if (containerRect === null || containerRect === void 0 ? void 0 : containerRect.width) {
      publish(YARL_EVENT_TOOLBAR_WIDTH, containerRect.width);
    }
  }, [publish, containerRect === null || containerRect === void 0 ? void 0 : containerRect.width]);
  const renderCloseButton = () => buttonClose ? buttonClose() : React28.createElement(IconButton, { key: ACTION_CLOSE, label: label(labels, "Close"), icon: CloseIcon, renderIcon: iconClose, onClick: () => publish(ACTION_CLOSE) });
  return React28.createElement("div", { ref: setContainerRef, className: cssClass(cssPrefix4()) }, buttons === null || buttons === void 0 ? void 0 : buttons.map((button) => button === ACTION_CLOSE ? renderCloseButton() : button));
}
var ToolbarModule = createModule(MODULE_TOOLBAR, Toolbar);

export {
  MODULE_CONTROLLER,
  PLUGIN_FULLSCREEN,
  PLUGIN_SLIDESHOW,
  PLUGIN_THUMBNAILS,
  PLUGIN_ZOOM,
  SLIDE_STATUS_LOADING,
  SLIDE_STATUS_PLAYING,
  SLIDE_STATUS_ERROR,
  SLIDE_STATUS_COMPLETE,
  ACTIVE_SLIDE_LOADING,
  ACTIVE_SLIDE_PLAYING,
  ACTIVE_SLIDE_ERROR,
  ACTIVE_SLIDE_COMPLETE,
  CLASS_FULLSIZE,
  CLASS_FLEX_CENTER,
  ACTION_PREV,
  ACTION_NEXT,
  ACTION_SWIPE,
  EVENT_ON_POINTER_DOWN,
  EVENT_ON_POINTER_MOVE,
  EVENT_ON_POINTER_UP,
  EVENT_ON_POINTER_LEAVE,
  EVENT_ON_POINTER_CANCEL,
  EVENT_ON_KEY_DOWN,
  EVENT_ON_WHEEL,
  ELEMENT_ICON,
  IMAGE_FIT_CONTAIN,
  IMAGE_FIT_COVER,
  LightboxDefaultProps,
  clsx,
  cssClass,
  cssVar,
  composePrefix,
  makeComposePrefix,
  label,
  cleanup,
  makeUseContext,
  round,
  isImageSlide,
  devicePixelRatio,
  getSlide,
  createModule,
  createNode,
  withPlugins,
  useLayoutEffect2 as useLayoutEffect,
  useMotionPreference,
  useAnimation,
  useContainerRect,
  useTimeouts,
  useEventCallback,
  useEvents,
  useLightboxState,
  useController,
  ControllerModule,
  useLoseFocus,
  useRTL,
  IconButton,
  createIcon,
  ImageSlide,
  CarouselModule,
  CoreModule,
  NavigationModule,
  NoScrollModule,
  PortalModule,
  ToolbarModule
};
//# sourceMappingURL=chunk-2TVOGE4U.js.map
