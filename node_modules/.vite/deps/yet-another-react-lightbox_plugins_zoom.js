import {
  CLASS_FLEX_CENTER,
  CLASS_FULLSIZE,
  EVENT_ON_KEY_DOWN,
  EVENT_ON_POINTER_CANCEL,
  EVENT_ON_POINTER_DOWN,
  EVENT_ON_POINTER_LEAVE,
  EVENT_ON_POINTER_MOVE,
  EVENT_ON_POINTER_UP,
  EVENT_ON_WHEEL,
  IMAGE_FIT_CONTAIN,
  IMAGE_FIT_COVER,
  IconButton,
  ImageSlide,
  MODULE_CONTROLLER,
  PLUGIN_ZOOM,
  cleanup,
  clsx,
  createIcon,
  createModule,
  cssClass,
  devicePixelRatio,
  isImageSlide,
  label,
  makeUseContext,
  round,
  useContainerRect,
  useController,
  useEventCallback,
  useEvents,
  useLayoutEffect,
  useLightboxState,
  useMotionPreference
} from "./chunk-2TVOGE4U.js";
import "./chunk-JZ3YVIXN.js";
import {
  require_react
} from "./chunk-6CE3F7YD.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/Zoom.js
var React6 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/ZoomContext.js
var React = __toESM(require_react(), 1);
var ZoomContext = React.createContext(null);
var useZoom = makeUseContext("useZoom", "ZoomContext", ZoomContext);
function ZoomContextProvider({ slides, children }) {
  const [isMinZoom, setIsMinZoom] = React.useState(false);
  const [isMaxZoom, setIsMaxZoom] = React.useState(false);
  const [isZoomSupported, setIsZoomSupported] = React.useState(false);
  const { currentIndex } = useLightboxState().state;
  const updateZoomSupported = useEventCallback(() => setIsZoomSupported(slides.length > currentIndex && isImageSlide(slides[currentIndex])));
  useLayoutEffect(updateZoomSupported, [currentIndex, updateZoomSupported]);
  const context = React.useMemo(() => ({
    isMinZoom,
    isMaxZoom,
    isZoomSupported,
    setIsMinZoom,
    setIsMaxZoom
  }), [isMinZoom, isMaxZoom, isZoomSupported]);
  return React.createElement(ZoomContext.Provider, { value: context }, children);
}

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/ZoomButtonsGroup.js
var React3 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/ZoomButton.js
var React2 = __toESM(require_react(), 1);
var ZoomInIcon = createIcon("ZoomIn", React2.createElement(
  React2.Fragment,
  null,
  React2.createElement("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }),
  React2.createElement("path", { d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" })
));
var ZoomOutIcon = createIcon("ZoomOut", React2.createElement("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z" }));
var ZoomButton = React2.forwardRef(({ labels, render, zoomIn, onLoseFocus }, ref) => {
  const wasEnabled = React2.useRef(false);
  const wasFocused = React2.useRef(false);
  const { isMinZoom, isMaxZoom, isZoomSupported } = useZoom();
  const { publish } = useEvents();
  const disabled = !isZoomSupported || (zoomIn ? isMaxZoom : isMinZoom);
  const onClick = () => publish(zoomIn ? ACTION_ZOOM_IN : ACTION_ZOOM_OUT);
  const onFocus = React2.useCallback(() => {
    wasFocused.current = true;
  }, []);
  const onBlur = React2.useCallback(() => {
    wasFocused.current = false;
  }, []);
  React2.useEffect(() => {
    if (disabled && wasEnabled.current && wasFocused.current) {
      onLoseFocus();
    }
    if (!disabled) {
      wasEnabled.current = true;
    }
  }, [disabled, onLoseFocus]);
  if (zoomIn && render.buttonZoomIn)
    return React2.createElement(React2.Fragment, null, render.buttonZoomIn({
      ref,
      labels,
      disabled,
      onClick,
      onFocus,
      onBlur
    }));
  if (!zoomIn && render.buttonZoomOut)
    return React2.createElement(React2.Fragment, null, render.buttonZoomOut({
      ref,
      labels,
      disabled,
      onClick,
      onFocus,
      onBlur
    }));
  return React2.createElement(IconButton, { ref, label: label(labels, zoomIn ? "Zoom in" : "Zoom out"), icon: zoomIn ? ZoomInIcon : ZoomOutIcon, renderIcon: zoomIn ? render.iconZoomIn : render.iconZoomOut, disabled, onClick, onFocus, onBlur });
});
ZoomButton.displayName = "ZoomButton";

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/ZoomButtonsGroup.js
function ZoomButtonsGroup({ labels, render }) {
  const zoomInRef = React3.useRef(null);
  const zoomOutRef = React3.useRef(null);
  const { transferFocus } = useController();
  const focusSibling = React3.useCallback((sibling) => {
    var _a, _b;
    if (!((_a = sibling.current) === null || _a === void 0 ? void 0 : _a.disabled)) {
      (_b = sibling.current) === null || _b === void 0 ? void 0 : _b.focus();
    } else {
      transferFocus();
    }
  }, [transferFocus]);
  const focusZoomIn = React3.useCallback(() => focusSibling(zoomInRef), [focusSibling]);
  const focusZoomOut = React3.useCallback(() => focusSibling(zoomOutRef), [focusSibling]);
  return React3.createElement(
    React3.Fragment,
    null,
    React3.createElement(ZoomButton, { ref: zoomInRef, key: ACTION_ZOOM_IN, zoomIn: true, labels, render, onLoseFocus: focusZoomOut }),
    React3.createElement(ZoomButton, { ref: zoomOutRef, key: ACTION_ZOOM_OUT, labels, render, onLoseFocus: focusZoomIn })
  );
}

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/ZoomContainer.js
var React5 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/ResponsiveImage.js
var React4 = __toESM(require_react(), 1);
function isResponsiveImageSlide(slide) {
  var _a;
  return (((_a = slide.srcSet) === null || _a === void 0 ? void 0 : _a.length) || 0) > 0;
}
function ResponsiveImage(props) {
  var _a, _b;
  const [state, setState] = React4.useState({});
  const { current, preload } = state;
  const { slide: image, rect, imageFit, render } = props;
  const srcSet = image.srcSet.sort((a, b) => a.width - b.width);
  const width = (_a = image.width) !== null && _a !== void 0 ? _a : srcSet[srcSet.length - 1].width;
  const height = (_b = image.height) !== null && _b !== void 0 ? _b : srcSet[srcSet.length - 1].height;
  const cover = image.imageFit === IMAGE_FIT_COVER || image.imageFit !== IMAGE_FIT_CONTAIN && imageFit === IMAGE_FIT_COVER;
  const maxWidth = Math.max(...srcSet.map((x) => x.width));
  const targetWidth = Math.min((cover ? Math.max : Math.min)(rect.width, width * (rect.height / height)), maxWidth);
  const pixelDensity = devicePixelRatio();
  const handleSourceChange = useEventCallback(() => {
    var _a2;
    const targetSource = (_a2 = srcSet.find((x) => x.width >= targetWidth * pixelDensity)) !== null && _a2 !== void 0 ? _a2 : srcSet[srcSet.length - 1];
    if (!current) {
      setState((prev) => ({ ...prev, current: targetSource.src }));
    } else if (srcSet.findIndex((x) => x.src === current) < srcSet.findIndex((x) => x === targetSource)) {
      setState((prev) => ({ ...prev, preload: targetSource.src }));
    }
  });
  useLayoutEffect(handleSourceChange, [rect === null || rect === void 0 ? void 0 : rect.width, rect === null || rect === void 0 ? void 0 : rect.height, pixelDensity, image.src, handleSourceChange]);
  const handlePreload = useEventCallback((currentPreload) => {
    if (currentPreload === preload) {
      setState((prev) => ({ ...prev, current: preload, preload: void 0 }));
    }
  });
  const style = {
    WebkitTransform: "translateZ(0)"
  };
  if (!cover) {
    Object.assign(style, rect.width / rect.height < width / height ? { width: "100%", height: "auto" } : { width: "auto", height: "100%" });
  }
  return React4.createElement(
    React4.Fragment,
    null,
    preload && preload !== current && React4.createElement(ImageSlide, { key: "preload", ...props, slide: { ...image, src: preload, srcSet: void 0 }, style: { position: "absolute", visibility: "hidden", ...style }, onLoad: () => handlePreload(preload), render: {
      ...render,
      iconLoading: () => null,
      iconError: () => null
    } }),
    current && React4.createElement(ImageSlide, { key: "current", ...props, slide: { ...image, src: current, srcSet: void 0 }, style })
  );
}

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/ZoomContainer.js
function getSlideRects(slide, cover, maxZoomPixelRatio, rect) {
  var _a, _b;
  let slideRect = { width: 0, height: 0 };
  let maxSlideRect = { width: 0, height: 0 };
  if (rect && isImageSlide(slide)) {
    const width = Math.max(...(((_a = slide.srcSet) === null || _a === void 0 ? void 0 : _a.map((x) => x.width)) || []).concat(slide.width ? [slide.width] : []));
    const height = Math.max(...(((_b = slide.srcSet) === null || _b === void 0 ? void 0 : _b.map((x) => x.height)) || []).concat(slide.height ? [slide.height] : []));
    if (width > 0 && height > 0 && rect.width > 0 && rect.height > 0) {
      maxSlideRect = cover ? {
        width: Math.round(Math.min(width, rect.width / rect.height * height)),
        height: Math.round(Math.min(height, rect.height / rect.width * width))
      } : { width, height };
      maxSlideRect = {
        width: maxSlideRect.width * maxZoomPixelRatio,
        height: maxSlideRect.height * maxZoomPixelRatio
      };
      slideRect = cover ? {
        width: Math.min(rect.width, maxSlideRect.width, width),
        height: Math.min(rect.height, maxSlideRect.height, height)
      } : {
        width: Math.round(Math.min(rect.width, rect.height / height * width, width)),
        height: Math.round(Math.min(rect.height, rect.width / width * height, height))
      };
    }
  }
  return { slideRect, maxSlideRect };
}
function distance(pointerA, pointerB) {
  return ((pointerA.clientX - pointerB.clientX) ** 2 + (pointerA.clientY - pointerB.clientY) ** 2) ** 0.5;
}
function ZoomContainer({ slide, offset, rect, render, carousel, animation, zoom: originalZoomProps, on }) {
  var _a;
  const zoomProps = { ...defaultZoomProps, ...originalZoomProps };
  const { currentIndex } = useLightboxState().state;
  const [zoom, setZoom] = React5.useState(1);
  const [offsetX, setOffsetX] = React5.useState(0);
  const [offsetY, setOffsetY] = React5.useState(0);
  const [imageDimensions, setImageDimensions] = React5.useState();
  const activePointers = React5.useRef([]);
  const lastPointerDown = React5.useRef(0);
  const zoomAnimation = React5.useRef();
  const zoomAnimationStart = React5.useRef();
  const pinchZoomDistance = React5.useRef();
  const { isMinZoom, isMaxZoom, setIsMinZoom, setIsMaxZoom } = useZoom();
  const { setContainerRef, containerRef, containerRect } = useContainerRect();
  const { subscribeSensors, containerRef: controllerRef, containerRect: controllerRect } = useController();
  const { subscribe } = useEvents();
  const reduceMotion = useMotionPreference();
  const { slideRect, maxSlideRect } = getSlideRects({ ...slide, ...imageDimensions }, carousel.imageFit === IMAGE_FIT_COVER || "imageFit" in slide && slide.imageFit === IMAGE_FIT_COVER, zoomProps.maxZoomPixelRatio, containerRect);
  const maxZoom = slideRect.width ? Math.max(round(maxSlideRect.width / slideRect.width, 5), 1) : 1;
  const changeOffsets = useEventCallback((dx, dy, targetZoom) => {
    const newZoom = targetZoom || zoom;
    const newOffsetX = offsetX - (dx || 0);
    const newOffsetY = offsetY - (dy || 0);
    const maxOffsetX = containerRect ? (slideRect.width * newZoom - containerRect.width) / 2 / newZoom : 0;
    const maxOffsetY = containerRect ? (slideRect.height * newZoom - containerRect.height) / 2 / newZoom : 0;
    setOffsetX(Math.min(Math.abs(newOffsetX), Math.max(maxOffsetX, 0)) * Math.sign(newOffsetX));
    setOffsetY(Math.min(Math.abs(newOffsetY), Math.max(maxOffsetY, 0)) * Math.sign(newOffsetY));
  });
  const changeZoom = useEventCallback((value, rapid, dx, dy) => {
    if (!containerRef.current || !containerRect)
      return;
    const newZoom = round(Math.min(Math.max(value + 1e-3 < maxZoom ? value : maxZoom, 1), maxZoom), 5);
    if (newZoom === zoom)
      return;
    if (!rapid) {
      zoomAnimationStart.current = window.getComputedStyle(containerRef.current).transform;
    }
    changeOffsets(dx ? dx * (1 / zoom - 1 / newZoom) : 0, dy ? dy * (1 / zoom - 1 / newZoom) : 0, newZoom);
    setZoom(newZoom);
  });
  const handleControllerRectChange = useEventCallback(() => {
    if (zoom > 1) {
      if (zoom > maxZoom) {
        changeZoom(maxZoom, true);
      }
      changeOffsets();
    }
  });
  useLayoutEffect(handleControllerRectChange, [
    controllerRect.width,
    controllerRect.height,
    handleControllerRectChange
  ]);
  const handleZoomAndOffsetChange = useEventCallback(() => {
    var _a2, _b, _c, _d;
    (_a2 = zoomAnimation.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
    if (zoomAnimationStart.current && containerRef.current) {
      zoomAnimation.current = (_c = (_b = containerRef.current).animate) === null || _c === void 0 ? void 0 : _c.call(_b, [
        { transform: zoomAnimationStart.current },
        { transform: `scale(${zoom}) translateX(${offsetX}px) translateY(${offsetY}px)` }
      ], {
        duration: !reduceMotion ? (_d = animation.zoom) !== null && _d !== void 0 ? _d : 500 : 0,
        easing: zoomAnimation.current ? "ease-out" : "ease-in-out"
      });
      zoomAnimationStart.current = void 0;
      if (zoomAnimation.current) {
        zoomAnimation.current.onfinish = () => {
          zoomAnimation.current = void 0;
        };
      }
    }
  });
  useLayoutEffect(handleZoomAndOffsetChange, [zoom, offsetX, offsetY, handleZoomAndOffsetChange]);
  useLayoutEffect(() => {
    if (offset === 0) {
      const resetZoom = () => {
        setZoom(1);
        setOffsetX(0);
        setOffsetY(0);
        setIsMinZoom(true);
        setIsMaxZoom(false);
      };
      resetZoom();
      return () => {
        resetZoom();
      };
    }
    return () => {
    };
  }, [offset, setIsMinZoom, setIsMaxZoom]);
  useLayoutEffect(() => {
    if (offset === 0) {
      const newMinZoom = zoom <= 1;
      if (newMinZoom !== isMinZoom) {
        setIsMinZoom(newMinZoom);
      }
      const newMaxZoom = zoom >= maxZoom;
      if (newMaxZoom !== isMaxZoom) {
        setIsMaxZoom(newMaxZoom);
      }
    }
  }, [offset, zoom, maxZoom, isMinZoom, isMaxZoom, setIsMinZoom, setIsMaxZoom]);
  const onZoomCallback = useEventCallback(() => {
    var _a2;
    if (offset === 0) {
      (_a2 = on.zoom) === null || _a2 === void 0 ? void 0 : _a2.call(on, zoom);
    }
  });
  useLayoutEffect(onZoomCallback, [zoom, onZoomCallback]);
  const translateCoordinates = React5.useCallback((event) => {
    if (controllerRef.current) {
      const { pageX, pageY } = event;
      const { scrollX, scrollY } = window;
      const { left, top, width, height } = controllerRef.current.getBoundingClientRect();
      return [pageX - left - scrollX - width / 2, pageY - top - scrollY - height / 2];
    }
    return [];
  }, [controllerRef]);
  const onKeyDown = useEventCallback((event) => {
    const { keyboardMoveDistance, zoomInMultiplier } = zoomProps;
    const preventDefault = () => {
      event.preventDefault();
      event.stopPropagation();
    };
    if (zoom > 1) {
      const move = (deltaX, deltaY) => {
        preventDefault();
        changeOffsets(deltaX, deltaY);
      };
      if (event.key === "ArrowDown") {
        move(0, keyboardMoveDistance);
      } else if (event.key === "ArrowUp") {
        move(0, -keyboardMoveDistance);
      } else if (event.key === "ArrowLeft") {
        move(-keyboardMoveDistance, 0);
      } else if (event.key === "ArrowRight") {
        move(keyboardMoveDistance, 0);
      }
    }
    const handleChangeZoom = (zoomValue) => {
      preventDefault();
      changeZoom(zoomValue);
    };
    const hasMeta = () => event.getModifierState("Meta");
    if (event.key === "+" || event.key === "=" && hasMeta()) {
      handleChangeZoom(zoom * zoomInMultiplier);
    } else if (event.key === "-" || event.key === "_" && hasMeta()) {
      handleChangeZoom(zoom / zoomInMultiplier);
    } else if (event.key === "0" && hasMeta()) {
      handleChangeZoom(1);
    }
  });
  const onWheel = useEventCallback((event) => {
    const { wheelZoomDistanceFactor, scrollToZoom } = zoomProps;
    if (event.ctrlKey || scrollToZoom) {
      if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {
        event.stopPropagation();
        changeZoom(zoom * (1 - event.deltaY / wheelZoomDistanceFactor), true, ...translateCoordinates(event));
        return;
      }
    }
    if (zoom > 1) {
      event.stopPropagation();
      if (!scrollToZoom) {
        changeOffsets(event.deltaX, event.deltaY);
      }
    }
  });
  const clearPointer = React5.useCallback((event) => {
    const pointers = activePointers.current;
    pointers.splice(0, pointers.length, ...pointers.filter((p) => p.pointerId !== event.pointerId));
  }, []);
  const replacePointer = React5.useCallback((event) => {
    clearPointer(event);
    event.persist();
    activePointers.current.push(event);
  }, [clearPointer]);
  const onPointerDown = useEventCallback((event) => {
    var _a2;
    const { doubleTapDelay, doubleClickDelay, zoomInMultiplier, doubleClickMaxStops } = zoomProps;
    const pointers = activePointers.current;
    if (!((_a2 = containerRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target))) {
      return;
    }
    if (zoom > 1) {
      event.stopPropagation();
    }
    const { timeStamp } = event;
    if (pointers.length === 0 && timeStamp - lastPointerDown.current < (event.pointerType === "touch" ? doubleTapDelay : doubleClickDelay)) {
      lastPointerDown.current = 0;
      changeZoom(zoom !== maxZoom ? zoom * Math.max(maxZoom ** (1 / doubleClickMaxStops), zoomInMultiplier) : 1, false, ...translateCoordinates(event));
    } else {
      lastPointerDown.current = timeStamp;
    }
    replacePointer(event);
    if (pointers.length === 2) {
      pinchZoomDistance.current = distance(pointers[0], pointers[1]);
    }
  });
  const onPointerMove = useEventCallback((event) => {
    const pointers = activePointers.current;
    const activePointer = pointers.find((p) => p.pointerId === event.pointerId);
    if (pointers.length === 2 && pinchZoomDistance.current) {
      event.stopPropagation();
      replacePointer(event);
      const currentDistance = distance(pointers[0], pointers[1]);
      const delta = currentDistance - pinchZoomDistance.current;
      if (Math.abs(delta) > 0) {
        changeZoom(zoom * (1 + delta / zoomProps.pinchZoomDistanceFactor), true, ...pointers.map((x) => translateCoordinates(x)).reduce((acc, coordinate) => coordinate.map((x, i) => acc[i] + x / 2)));
        pinchZoomDistance.current = currentDistance;
      }
      return;
    }
    if (zoom > 1) {
      event.stopPropagation();
      if (activePointer) {
        if (pointers.length === 1) {
          changeOffsets((activePointer.clientX - event.clientX) / zoom, (activePointer.clientY - event.clientY) / zoom);
        }
        replacePointer(event);
      }
    }
  });
  const onPointerUp = React5.useCallback((event) => {
    const pointers = activePointers.current;
    if (pointers.length === 2 && pointers.find((p) => p.pointerId === event.pointerId)) {
      pinchZoomDistance.current = void 0;
    }
    clearPointer(event);
  }, [clearPointer]);
  const handleZoomIn = useEventCallback(() => {
    changeZoom(zoom * zoomProps.zoomInMultiplier);
  });
  const handleZoomOut = useEventCallback(() => {
    changeZoom(zoom / zoomProps.zoomInMultiplier);
  });
  React5.useEffect(() => offset === 0 ? cleanup(subscribe(ACTION_ZOOM_IN, handleZoomIn), subscribe(ACTION_ZOOM_OUT, handleZoomOut), subscribeSensors(EVENT_ON_KEY_DOWN, onKeyDown), subscribeSensors(EVENT_ON_WHEEL, onWheel), subscribeSensors(EVENT_ON_POINTER_DOWN, onPointerDown), subscribeSensors(EVENT_ON_POINTER_MOVE, onPointerMove), subscribeSensors(EVENT_ON_POINTER_UP, onPointerUp), subscribeSensors(EVENT_ON_POINTER_LEAVE, onPointerUp), subscribeSensors(EVENT_ON_POINTER_CANCEL, onPointerUp)) : () => {
  }, [
    offset,
    subscribe,
    subscribeSensors,
    onKeyDown,
    onPointerDown,
    onPointerMove,
    onPointerUp,
    onWheel,
    changeZoom,
    handleZoomIn,
    handleZoomOut
  ]);
  const scaledRect = offset === 0 ? {
    width: rect.width * zoom,
    height: rect.height * zoom
  } : rect;
  let rendered = (_a = render.slide) === null || _a === void 0 ? void 0 : _a.call(render, slide, offset, scaledRect);
  if (!rendered && isImageSlide(slide)) {
    const slideProps = {
      slide,
      offset,
      rect,
      render,
      imageFit: carousel.imageFit,
      onClick: offset === 0 ? () => {
        var _a2;
        return (_a2 = on.click) === null || _a2 === void 0 ? void 0 : _a2.call(on, currentIndex);
      } : void 0
    };
    rendered = isResponsiveImageSlide(slide) ? React5.createElement(ResponsiveImage, { ...slideProps, slide, rect: scaledRect }) : React5.createElement(ImageSlide, { onLoad: (img) => setImageDimensions({ width: img.naturalWidth, height: img.naturalHeight }), ...slideProps });
  }
  return rendered ? React5.createElement("div", { ref: setContainerRef, className: clsx(cssClass(CLASS_FULLSIZE), cssClass(CLASS_FLEX_CENTER)), ...offset === 0 ? { style: { transform: `scale(${zoom}) translateX(${offsetX}px) translateY(${offsetY}px)` } } : null }, rendered) : null;
}

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/Zoom.js
var defaultZoomProps = {
  maxZoomPixelRatio: 1,
  zoomInMultiplier: 2,
  doubleTapDelay: 300,
  doubleClickDelay: 500,
  doubleClickMaxStops: 2,
  keyboardMoveDistance: 50,
  wheelZoomDistanceFactor: 100,
  pinchZoomDistanceFactor: 100,
  scrollToZoom: false
};
var Zoom = ({ augment, append }) => {
  augment(({ toolbar: { buttons, ...restToolbar }, render, carousel, animation, zoom, on, ...restProps }) => ({
    toolbar: {
      buttons: [React6.createElement(ZoomButtonsGroup, { key: PLUGIN_ZOOM, labels: restProps.labels, render }), ...buttons],
      ...restToolbar
    },
    render: {
      ...render,
      slide: (slide, offset, rect) => {
        var _a;
        return isImageSlide(slide) ? React6.createElement(ZoomContainer, { slide, offset, rect, render, carousel, animation, zoom, on }) : (_a = render.slide) === null || _a === void 0 ? void 0 : _a.call(render, slide, offset, rect);
      }
    },
    zoom: {
      ...defaultZoomProps,
      ...zoom
    },
    carousel,
    animation,
    on,
    ...restProps
  }));
  append(MODULE_CONTROLLER, createModule(PLUGIN_ZOOM, ZoomContextProvider));
};

// node_modules/yet-another-react-lightbox/dist/plugins/zoom/index.js
var ACTION_ZOOM_IN = "zoom-in";
var ACTION_ZOOM_OUT = "zoom-out";
var zoom_default = Zoom;
export {
  ACTION_ZOOM_IN,
  ACTION_ZOOM_OUT,
  zoom_default as default
};
//# sourceMappingURL=yet-another-react-lightbox_plugins_zoom.js.map
